#!/bin/bash
set -euo pipefail
[[ -n "${DEBUG:-}" ]] && set -x

# UFW-Docker script configuration
AFTER_RULES="/etc/ufw/after.rules"
AFTER6_RULES="/etc/ufw/after6.rules"
AFTER_RULES_ORIGINAL="/etc/ufw/after.rules_original"
AFTER6_RULES_ORIGINAL="/etc/ufw/after6.rules_original"
INIT_AFTER_RULES="${0%/*}/after.rules"
INIT_AFTER6_RULES="${0%/*}/after6.rules"
SCRIPT_DIR="$(cd "${0%/*}" 2>/dev/null && pwd)"
GITHUB_BASE="https://raw.githubusercontent.com/xiiizoux/ufw-docker/refs/heads/main"

# Container port section markers
SECTION_MARKER_IPV4="# 4. Container port access rules (add your rules here)"
SECTION_MARKER_IPV6="# 4. Container port access rules (add your rules here)"

function die() {
    echo "ERROR: $*" >&2
    exit 1
}

function info() {
    echo "$*" >&2
}

function err() {
    echo "$*" >&2
}

# Check if UFW is active
function check_ufw() {
    if ! command -v ufw >/dev/null 2>&1; then
        die "ufw command not found"
    fi
    
    # Don't require UFW to be active for all commands
    if [[ "${1:-}" == "strict" ]]; then
        if ! ufw status 2>/dev/null | grep -Fq "Status: active"; then
            die "UFW is not active or you don't have sufficient privileges"
        fi
    fi
}

# Backup files
function backup_file() {
    local file="$1"
    if [[ -f "$file" ]]; then
        local backup="${file}-ufwd-backup-$(date '+%Y%m%d-%H%M%S')"
        cp "$file" "$backup" && echo "$backup" >&2
        return 0
    fi
    return 1
}

# Find the marker line in file
function find_marker_line() {
    local file="$1"
    local marker="$2"
    grep -n "$marker" "$file" 2>/dev/null | head -1 | cut -d: -f1
}

# Calculate rule specificity for sorting (more specific = higher score)
function calculate_rule_specificity() {
    local rule="$1"
    local score=0
    
    # More criteria = more specific rule
    if [[ "$rule" =~ -s\ [^[:space:]]+ ]]; then
        ((score += 20))  # Source IP makes rule more specific
    fi
    if [[ "$rule" =~ -d\ [^[:space:]]+ ]]; then
        ((score += 10))  # Destination IP
    fi
    if [[ "$rule" =~ --dport\ [0-9]+ ]]; then
        ((score += 5))   # Port specification
    fi
    if [[ "$rule" =~ -p\ [^[:space:]]+ ]]; then
        ((score += 1))   # Protocol
    fi
    
    echo "$score"
}

# Add a rule after the marker line with automatic sorting by specificity
function add_rule_after_marker() {
    local file="$1"
    local marker="$2"
    local rule="$3"
    
    if [[ ! -f "$file" ]]; then
        die "File not found: $file"
    fi
    
    local marker_line
    marker_line=$(find_marker_line "$file" "$marker")
    
    if [[ -z "$marker_line" ]]; then
        die "Section marker not found in $file: $marker"
    fi
    
    # Check if rule already exists
    if printf '%s\n' "$rule" | grep -Fqf /dev/stdin "$file" 2>/dev/null; then
        return 0
    fi
    
    # Calculate specificity of the new rule
    local new_rule_specificity
    new_rule_specificity=$(calculate_rule_specificity "$rule")
    
    # Find the next section line
    local next_section_line
    next_section_line=$(awk -v marker="$marker_line" '
        NR > marker {
            if ($0 ~ /^# [0-9]+\./) {
                print NR
                exit
            }
        }
        END {
            print NR + 1
        }
    ' "$file" | head -1)
    
    # Create temp file
    local temp_file
    temp_file=$(mktemp)
    
    # Write everything up to and including marker line
    head -n "$marker_line" "$file" > "$temp_file"
    
    # Collect all existing rules and their specificities
    local rules_array=()
    local specificities_array=()
    local other_lines=()
    
    # Read from marker+1 to end of file
    local line_num=$((marker_line + 1))
    while IFS= read -r line || [[ -n "$line" ]]; do
        if (( line_num >= next_section_line )); then
            # Store lines after the user section
            other_lines+=("$line")
        elif [[ "$line" =~ ^-A[[:space:]]+DOCKER-USER ]]; then
            # This is a rule - store it for sorting
            local spec=$(calculate_rule_specificity "$line")
            specificities_array+=("$spec")
            rules_array+=("$line")
        fi
        # Note: Comments and blank lines in section 4 are not preserved
        # Only user-added rules are stored and sorted
        ((line_num++))
    done < <(tail -n +$((marker_line + 1)) "$file")
    
    # Add the new rule
    specificities_array+=("$new_rule_specificity")
    rules_array+=("$rule")
    
    # Sort rules by specificity (descending - most specific first)
    # Use indices array for sorting
    local indices=()
    for i in "${!rules_array[@]}"; do
        indices+=("$i")
    done
    
    # Bubble sort by specificity (descending)
    local n=${#rules_array[@]}
    for ((i=0; i<n-1; i++)); do
        for ((j=0; j<n-i-1; j++)); do
            if (( specificities_array[indices[j]] < specificities_array[indices[j+1]] )); then
                # Swap indices
                local temp=${indices[j]}
                indices[j]=${indices[j+1]}
                indices[j+1]=$temp
            fi
        done
    done
    
    # Now write the sorted rules
    for i in "${indices[@]}"; do
        echo "${rules_array[i]}" >> "$temp_file"
    done
    
    # Write remaining lines (section headers, etc.)
    for line in "${other_lines[@]}"; do
        echo "$line" >> "$temp_file"
    done
    
    # Replace original file
    cp "$temp_file" "$file"
    rm "$temp_file"
}

# Delete a rule (fuzzy match by pattern)
function delete_rule_by_pattern() {
    local file="$1"
    local marker="$2"
    local pattern="$3"  # A substring or multiple substrings to match
    
    if [[ ! -f "$file" ]]; then
        return 0
    fi
    
    local marker_line
    marker_line=$(find_marker_line "$file" "$marker")
    
    if [[ -z "$marker_line" ]]; then
        return 0
    fi
    
    # Check if pattern exists after the marker line
    local found=false
    local temp_file
    temp_file=$(mktemp)
    
    local line_num=0
    while IFS= read -r line || [[ -n "$line" ]]; do
        ((line_num++))
        
        # Check if line contains ALL pattern components and is after marker
        if [[ $line_num -gt $marker_line ]] && [[ -n "$pattern" ]]; then
            local should_delete=true
            
            # If pattern contains "--dport", check for port match
            if [[ "$pattern" =~ --dport\ ([0-9]+) ]]; then
                local port="${BASH_REMATCH[1]}"
                if [[ ! "$line" = *--dport\ $port* ]]; then
                    should_delete=false
                fi
            fi
            
            # If pattern contains "-s", check for source match  
            if [[ "$pattern" =~ -s\ (.+) ]]; then
                local src="${BASH_REMATCH[1]}"
                if [[ ! "$line" = *-s\ $src* ]]; then
                    should_delete=false
                fi
            fi
            
            # Delete the line if ALL pattern components match
            if [[ "$should_delete" == true ]]; then
                found=true
                continue
            fi
        fi
        
        echo "$line" >> "$temp_file"
    done < "$file"
    
    if [[ "$found" == true ]]; then
        cp "$temp_file" "$file"
        rm "$temp_file"
        return 0
    fi
    
    rm "$temp_file"
    return 1
}

# Parse ufw-style arguments and extract relevant info
function parse_ufw_args() {
    local args=("$@")
    local proto=""
    local port=""
    local src=""
    local dst=""
    
    local i=0
    while [[ $i -lt ${#args[@]} ]]; do
        local arg="${args[$i]}"
        local next_arg="${args[$i+1]:-}"
        
        case "$arg" in
            proto)
                ((i++))
                proto="$next_arg"
                ;;
            protocol)
                ((i++))
                proto="$next_arg"
                ;;
            from)
                ((i++))
                src="$next_arg"
                ;;
            to)
                ((i++))
                dst="$next_arg"
                ;;
            port)
                ((i++))
                port="$next_arg"
                ;;
            in)
                ((i++))
                # Ignore interface for now
                ;;
            out)
                ((i++))
                # Ignore interface for now
                ;;
            *)
                # Handle inline formats
                if [[ "$arg" =~ ^[0-9]+(/(tcp|udp))$ ]]; then
                    # Format: "80/tcp" or "53/udp"
                    port="${arg%%/*}"
                    proto="${arg#*/}"
                elif [[ "$arg" =~ ^[0-9]+$ ]] && [[ -z "$port" ]]; then
                    # Just a number: assume it's a port
                    port="$arg"
                elif [[ "$arg" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}/[0-9]+$ ]]; then
                    # IPv4 with CIDR
                    [[ -z "$src" ]] && src="$arg"
                elif [[ "$arg" =~ ^[0-9a-fA-F:]+/[0-9]+$ ]]; then
                    # IPv6 with CIDR
                    [[ -z "$src" ]] && src="$arg"
                fi
                ;;
        esac
        
        ((i++))
    done
    
    # Set defaults
    proto="${proto:-tcp}"
    
    echo "$proto|$port|$src|$dst"
}

# Build iptables rule
function build_iptables_rule() {
    local action="$1"  # allow, deny, reject
    shift
    
    local parsed
    parsed=$(parse_ufw_args "$@")
    
    local proto="${parsed%%|*}"
    local rest="${parsed#*|}"
    local port="${rest%%|*}"
    local rest2="${rest#*|}"
    local src="${rest2%%|*}"
    local dst="${rest2#*|}"
    
    # Start building the rule
    local rule="-A DOCKER-USER"
    
    # Add protocol
    if [[ -n "$proto" ]]; then
        rule="$rule -p $proto"
    fi
    
    # Add destination port if port is specified
    if [[ -n "$port" ]]; then
        rule="$rule -m $proto --dport $port"
    fi
    
    # Add source IP
    if [[ -n "$src" ]]; then
        rule="$rule -s $src"
    fi
    
    # Add destination IP
    if [[ -n "$dst" ]]; then
        rule="$rule -d $dst"
    fi
    
    # Add the target action
    case "$action" in
        allow)
            rule="$rule -j RETURN"
            ;;
        deny)
            rule="$rule -j DROP"
            ;;
        reject)
            rule="$rule -j REJECT --reject-with icmp-port-unreachable"
            ;;
        *)
            rule="$rule -j RETURN"
            ;;
    esac
    
    echo "$rule"
}

# Build pattern for deletion - use multiple patterns for better matching
function build_delete_pattern() {
    local args=("$@")
    
    local parsed
    parsed=$(parse_ufw_args "${args[@]}")
    
    local proto="${parsed%%|*}"
    local rest="${parsed#*|}"
    local port="${rest%%|*}"
    local rest2="${rest#*|}"
    local src="${rest2%%|*}"
    
    # Build pattern string for matching
    # We'll match the key components that uniquely identify the rule
    local pattern=""
    local parts=()
    
    # Add port pattern if port is specified
    if [[ -n "$port" ]]; then
        parts+=("--dport $port")
    fi
    
    # Add source pattern if specified
    if [[ -n "$src" ]]; then
        parts+=("-s $src")
    fi
    
    # Combine parts
    if [[ ${#parts[@]} -gt 0 ]]; then
        pattern=$(IFS=" " ; echo "${parts[*]}")
    fi
    
    echo "$pattern"
}

# Download file from GitHub with error handling
function download_from_github() {
    local url="$1"
    local output="$2"
    local description="$3"
    
    info "Downloading $description from GitHub..."
    
    # Check if curl is available
    if ! command -v curl >/dev/null 2>&1; then
        die "curl is required but not installed. Please install curl first."
    fi
    
    # Try to download with timeout and retry
    if ! curl -fsSL --connect-timeout 10 --max-time 30 --retry 2 "$url" -o "$output" 2>/dev/null; then
        local status_code
        status_code=$(curl -sSLo /dev/null -w "%{http_code}" --connect-timeout 10 "$url" 2>/dev/null || echo "000")
        
        if [[ -f "$output" ]]; then
            rm -f "$output"
        fi
        
        die "Failed to download $description from GitHub." \
            "Status code: $status_code" \
            "URL: $url" \
            "Please check your network connection and try again later." \
            "Your UFW configuration was not modified."
    fi
    
    # Verify downloaded file is not empty
    if [[ ! -s "$output" ]]; then
        rm -f "$output"
        die "Downloaded $description is empty. Your UFW configuration was not modified."
    fi
    
    info "✓ Downloaded $description"
}

# Handle init command
function handle_init() {
    info "Initializing ufwd..."
    
    # Resolve full paths for init files
    # Try in this order:
    # 1. Next to the script (./after.rules)
    # 2. In script's directory
    # 3. In /usr/local/share/ufwd
    # 4. In /etc/ufwd
    # 5. Download from GitHub
    local init_after init_after6
    local temp_dir
    
    for candidate in \
        "${0%/*}/after.rules" \
        "$(dirname "$(readlink -f "$0")")/after.rules" \
        "/usr/local/share/ufwd/after.rules" \
        "/etc/ufwd/after.rules" \
        "./after.rules"; do
        if [[ -f "$candidate" ]]; then
            init_after="$candidate"
            break
        fi
    done
    
    for candidate in \
        "${0%/*}/after6.rules" \
        "$(dirname "$(readlink -f "$0")")/after6.rules" \
        "/usr/local/share/ufwd/after6.rules" \
        "/etc/ufwd/after6.rules" \
        "./after6.rules"; do
        if [[ -f "$candidate" ]]; then
            init_after6="$candidate"
            break
        fi
    done
    
    # If not found locally, download from GitHub
    if [[ ! -f "$init_after" ]] || [[ ! -f "$init_after6" ]]; then
        temp_dir=$(mktemp -d)
        
        if [[ ! -f "$init_after" ]]; then
            download_from_github "${GITHUB_BASE}/after.rules" "$temp_dir/after.rules" "after.rules"
            init_after="$temp_dir/after.rules"
        fi
        
        if [[ ! -f "$init_after6" ]]; then
            download_from_github "${GITHUB_BASE}/after6.rules" "$temp_dir/after6.rules" "after6.rules"
            init_after6="$temp_dir/after6.rules"
        fi
        
        # Cleanup temp directory on exit
        trap "rm -rf \"$temp_dir\"" EXIT
    fi
    
    info "Using init files from:"
    info "  IPv4: $init_after"
    info "  IPv6: $init_after6"
    
    # Backup original files if they don't exist yet
    if [[ ! -f "$AFTER_RULES_ORIGINAL" ]]; then
        info "Backing up original files..."
        if [[ -f "$AFTER_RULES" ]]; then
            cp "$AFTER_RULES" "$AFTER_RULES_ORIGINAL"
            info "✓ Backed up $AFTER_RULES to $AFTER_RULES_ORIGINAL"
        fi
    else
        info "Original backup already exists: $AFTER_RULES_ORIGINAL (skipping backup)"
    fi
    
    if [[ ! -f "$AFTER6_RULES_ORIGINAL" ]]; then
        if [[ -f "$AFTER6_RULES" ]]; then
            cp "$AFTER6_RULES" "$AFTER6_RULES_ORIGINAL"
            info "✓ Backed up $AFTER6_RULES to $AFTER6_RULES_ORIGINAL"
        fi
    else
        info "Original backup already exists: $AFTER6_RULES_ORIGINAL (skipping backup)"
    fi
    
    info "Installing initial rule files..."
    cp "$init_after" "$AFTER_RULES"
    info "✓ Installed $AFTER_RULES"
    
    cp "$init_after6" "$AFTER6_RULES"
    info "✓ Installed $AFTER6_RULES"
    
    info ""
    info "Setup complete! Please restart UFW to apply changes:"
    info "  sudo systemctl restart ufw"
    info ""
    info "To restore original files, use: sudo ufwd uninit"
}

# Handle uninit command
function handle_uninit() {
    info "Uninitializing ufwd..."
    
    # Check if original backups exist
    local restored=false
    
    if [[ -f "$AFTER_RULES_ORIGINAL" ]]; then
        info "Restoring $AFTER_RULES from original backup..."
        cp "$AFTER_RULES_ORIGINAL" "$AFTER_RULES"
        info "✓ Restored $AFTER_RULES"
        restored=true
    else
        info "⚠ No original backup found for $AFTER_RULES"
    fi
    
    if [[ -f "$AFTER6_RULES_ORIGINAL" ]]; then
        info "Restoring $AFTER6_RULES from original backup..."
        cp "$AFTER6_RULES_ORIGINAL" "$AFTER6_RULES"
        info "✓ Restored $AFTER6_RULES"
        restored=true
    else
        info "⚠ No original backup found for $AFTER6_RULES"
    fi
    
    if [[ "$restored" == true ]]; then
        info ""
        info "✓ Original files restored!"
        info "  Please restart UFW to apply changes:"
        info "  sudo systemctl restart ufw"
    else
        info ""
        die "No original backup files found. Cannot restore."
    fi
}

# Handle allow/deny/reject commands
function handle_rule() {
    local action="$1"
    shift
    
    check_ufw strict
    
    # Build the iptables rule
    local rule
    rule=$(build_iptables_rule "$action" "$@")
    
    # Determine if this is IPv6 based on source or destination address in the rule itself
    local is_ipv6=false
    # Check if the rule contains IPv6 address (contains ::)
    if [[ "$rule" =~ :: ]]; then
        is_ipv6=true
    fi
    
    # Add to appropriate file(s)
    # IPv6 rules go to after6.rules only
    # IPv4 rules go to after.rules only
    if [[ "$is_ipv6" == true ]]; then
        # IPv6 address: only add to IPv6 file
        add_rule_after_marker "$AFTER6_RULES" "$SECTION_MARKER_IPV6" "$rule"
    else
        # IPv4 address or no address: only add to IPv4 file
        add_rule_after_marker "$AFTER_RULES" "$SECTION_MARKER_IPV4" "$rule"
    fi
}

# Handle status command - show only ufwd-managed rules
function handle_status() {
    local cmd="${1:-status}"
    local has_rules=false
    
    # Read rules from after.rules
    if [[ -f "$AFTER_RULES" ]]; then
        local marker_line_ipv4
        marker_line_ipv4=$(find_marker_line "$AFTER_RULES" "$SECTION_MARKER_IPV4")
        
        if [[ -n "$marker_line_ipv4" ]]; then
            local rule_num=1
            local has_ipv4_rules=false
            
            # Use awk to extract rules between marker and next section
            # ONLY show rules that are in the user section (between marker and next numbered section)
            local awk_result
            awk_result=$(awk -v marker="$marker_line_ipv4" '
                NR > marker {
                    if ($0 ~ /^# [0-9]+\./) {
                        exit
                    }
                    if ($0 ~ /^-A[[:space:]]+DOCKER-USER/) {
                        print
                    }
                }
            ' "$AFTER_RULES" 2>/dev/null)
            
            if [[ -n "$awk_result" ]]; then
                while IFS= read -r rule; do
                    [[ -z "$rule" ]] && continue
                    if [[ "$has_ipv4_rules" == false ]]; then
                        echo "IPv4 Rules:"
                        has_ipv4_rules=true
                        has_rules=true
                    fi
                    if [[ "$cmd" = *numbered* ]]; then
                        echo "[$rule_num] $rule"
                    else
                        echo "  $rule"
                    fi
                    ((rule_num++))
                done <<< "$awk_result"
            fi
        fi
    fi
    
    # Read rules from after6.rules
    if [[ -f "$AFTER6_RULES" ]]; then
        local marker_line_ipv6
        marker_line_ipv6=$(find_marker_line "$AFTER6_RULES" "$SECTION_MARKER_IPV6")
        
        if [[ -n "$marker_line_ipv6" ]]; then
            local rule_num=1
            local has_ipv6_rules=false
            
            # Use awk to extract rules between marker and next section
            local awk_result
            awk_result=$(awk -v marker="$marker_line_ipv6" '
                NR > marker {
                    if ($0 ~ /^# [0-9]+\./) {
                        exit
                    }
                    if ($0 ~ /^-A[[:space:]]+DOCKER-USER/) {
                        print
                    }
                }
            ' "$AFTER6_RULES" 2>/dev/null)
            
            if [[ -n "$awk_result" ]]; then
                while IFS= read -r rule; do
                    [[ -z "$rule" ]] && continue
                    if [[ "$has_ipv6_rules" == false ]]; then
                        echo "IPv6 Rules:"
                        has_ipv6_rules=true
                        has_rules=true
                    fi
                    if [[ "$cmd" = *numbered* ]]; then
                        echo "[$rule_num] $rule"
                    else
                        echo "  $rule"
                    fi
                    ((rule_num++))
                done <<< "$awk_result"
            fi
        fi
    fi
    
    if [[ "$has_rules" == false ]]; then
        echo "No rules configured"
    fi
}

# Handle show command
function handle_show() {
    handle_status "status"
}

# Handle delete command
function handle_delete() {
    # Arguments are: allow/deny/reject, from, XXX, to, any, port, YYY
    local first_arg="${1:-}"
    
    local action="${first_arg}"
    
    # Validate the action
    if [[ "$action" != "allow" && "$action" != "deny" && "$action" != "reject" ]]; then
        # This is likely a numbered delete (ufw delete 1) or invalid
        if [[ "$action" =~ ^[0-9]+$ ]]; then
            ufw delete "$@"
            return
        fi
        
        # Invalid command
        die "Invalid delete command syntax. Expected: ufwd delete [allow|deny|reject] ARGS"
    fi
    
    # Skip the action to get remaining parameters
    shift
    
    check_ufw strict
    
    # Build pattern for deletion
    # This will only delete rules from after.rules and after6.rules, NOT from ufw
    local pattern
    pattern=$(build_delete_pattern "$@")
    
    if [[ -z "$pattern" ]]; then
        die "Unable to determine pattern for deletion. Please specify port or source."
    fi
    
    # IMPORTANT: We ONLY delete from after.rules and after6.rules files
    # We do NOT call ufw delete command
    
    local deleted_v4=false
    local deleted_v6=false
    
    if delete_rule_by_pattern "$AFTER_RULES" "$SECTION_MARKER_IPV4" "$pattern"; then
        deleted_v4=true
    fi
    
    if delete_rule_by_pattern "$AFTER6_RULES" "$SECTION_MARKER_IPV6" "$pattern"; then
        deleted_v6=true
    fi
    
    if [[ "$deleted_v4" == true ]] || [[ "$deleted_v6" == true ]]; then
        info "✓ Rule deleted"
    else
        info "Could not delete: rule not found"
    fi
}

# Main command dispatcher
function main() {
    local cmd="${1:-help}"
    
    case "$cmd" in
        init)
            # ufwd-specific: initialize rule files
            handle_init "$@"
            ;;
        uninit)
            # ufwd-specific: restore original rule files
            handle_uninit "$@"
            ;;
        allow|deny|reject)
            # Handle rule additions
            handle_rule "$cmd" "$@"
            ;;
        limit)
            # ufwd doesn't handle limit, use ufw directly
            echo "Note: 'limit' is not supported by ufwd. Use 'ufw limit' for rate limiting." >&2
            ufw "$@"
            ;;
    delete)
            # Handle rule deletions - ONLY from after.rules files
            # The full command is: ufwd delete allow from XXX
            # So we pass everything after "delete" to handle_delete
            shift  # Skip "delete", remaining args are the action and parameters
            handle_delete "$@"
            ;;
        insert|prepend)
            # ufwd doesn't support insert/prepend, use ufw directly
            echo "Note: 'insert/prepend' are not supported by ufwd." >&2
            ufw "$@"
            ;;
        route|"route delete"|"route insert")
            # ufwd doesn't handle route rules, use ufw directly
            echo "Note: 'route' rules are not managed by ufwd. Use 'ufw route' for NAT rules." >&2
            ufw "$@"
            ;;
        enable|disable)
            # ufwd doesn't control firewall state, use ufw directly
            ufw "$@"
            ;;
        default|logging)
            # ufwd doesn't manage defaults/logging, use ufw directly
            ufw "$@"
            ;;
        reload|reset)
            # ufwd doesn't control reload/reset, use ufw directly
            echo "Note: Use 'ufw reload' or 'ufw reset' for firewall operations." >&2
            ufw "$@"
        ;;
    status)
            # Show ufwd-managed rules from after.rules files only
            shift  # Skip "status"
            handle_status "status" "$@"
            ;;
        "status numbered")
            shift  # Skip "status"
            shift  # Skip "numbered"
            handle_status "status numbered" "$@"
            ;;
        "status verbose")
            shift  # Skip "status"
            shift  # Skip "verbose"
            handle_status "status verbose" "$@"
            ;;
        show)
            # Show ufwd-managed rules
            handle_show "$@"
            ;;
        version)
            # Show version information
            echo "ufwd - UFW Docker port management wrapper"
            echo "Wrapped ufw version:"
            ufw "$@"
            ;;
        app)
            # Application profile commands
            ufw "$@"
            ;;
        help|--help|-h)
            # Show help
            echo "UFWD - UFW Docker Port Management"
            echo ""
            echo "Usage: ufwd COMMAND"
            echo ""
            echo "UFWD-specific commands:"
            echo "  init              Initialize ufwd rule files"
            echo "  uninit            Restore original UFW rule files"
            echo ""
            echo "UFWD-managed rule operations (only affects after.rules files):"
            echo "  allow ARGS        add allow rule to after.rules"
            echo "  deny ARGS         add deny rule to after.rules"
            echo "  reject ARGS       add reject rule to after.rules"
            echo "  delete allow ARGS delete allow rule from after.rules"
            echo "  delete deny ARGS  delete deny rule from after.rules"
            echo "  delete reject ARGS delete reject rule from after.rules"
            echo "  status            show ufwd-managed rules (from after.rules only)"
            echo ""
            echo "Other commands (passed to ufw for system management):"
            echo "  enable/disable    enable/disable firewall"
            echo "  reload/reset      reload/reset firewall"
            echo "  app               application profile commands"
            echo ""
            echo "Examples:"
            echo "  sudo ufwd init"
            echo "  sudo ufwd allow 80/tcp"
            echo "  sudo ufwd allow 443/tcp from 173.245.48.0/20"
            echo "  sudo ufwd delete allow 80/tcp"
            echo "  sudo ufwd status"
            echo ""
            echo "For full UFW documentation, see: man ufw"
            ;;
        *)
            # Pass everything else to ufw
            ufw "$@"
        ;;
esac
}

# Run main
main "$@"