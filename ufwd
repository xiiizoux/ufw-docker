#!/bin/bash
set -euo pipefail
[[ -n "${DEBUG:-}" ]] && set -x

# UFW-Docker script configuration
AFTER_RULES="/etc/ufw/after.rules"
AFTER6_RULES="/etc/ufw/after6.rules"
AFTER_RULES_ORIGINAL="/etc/ufw/after.rules_original"
AFTER6_RULES_ORIGINAL="/etc/ufw/after6.rules_original"
INIT_AFTER_RULES="${0%/*}/after.rules"
INIT_AFTER6_RULES="${0%/*}/after6.rules"
SCRIPT_DIR="$(cd "${0%/*}" 2>/dev/null && pwd)"
GITHUB_BASE="https://raw.githubusercontent.com/xiiizoux/ufw-docker/refs/heads/main"

# Container port section markers
SECTION_MARKER_IPV4="# 4. Container port access rules (add your rules here)"
SECTION_MARKER_IPV6="# 4. Container port access rules (add your rules here)"

function die() {
    echo "ERROR: $*" >&2
    exit 1
}

function info() {
    echo "$*" >&2
}

function err() {
    echo "$*" >&2
}

# Check if UFW is active
function check_ufw() {
    if ! command -v ufw >/dev/null 2>&1; then
        die "ufw command not found"
    fi
    
    # Don't require UFW to be active for all commands
    if [[ "${1:-}" == "strict" ]]; then
        if ! ufw status 2>/dev/null | grep -Fq "Status: active"; then
            die "UFW is not active or you don't have sufficient privileges"
        fi
    fi
}

# Backup files
function backup_file() {
    local file="$1"
    if [[ -f "$file" ]]; then
        local backup="${file}-ufwd-backup-$(date '+%Y%m%d-%H%M%S')"
        cp "$file" "$backup" && echo "$backup" >&2
        return 0
    fi
    return 1
}

# Find the marker line in file
function find_marker_line() {
    local file="$1"
    local marker="$2"
    grep -n "$marker" "$file" 2>/dev/null | head -1 | cut -d: -f1
}

# Add a rule after the marker line
function add_rule_after_marker() {
    local file="$1"
    local marker="$2"
    local rule="$3"
    
    if [[ ! -f "$file" ]]; then
        die "File not found: $file"
    fi
    
    local marker_line
    marker_line=$(find_marker_line "$file" "$marker")
    
    if [[ -z "$marker_line" ]]; then
        die "Section marker not found in $file: $marker"
    fi
    
    # Check if rule already exists (use simple pattern matching to avoid issues with long rules)
    # Escape the rule for grep and check with fgrep for exact match
    if printf '%s\n' "$rule" | grep -Fqf /dev/stdin "$file" 2>/dev/null; then
        info "Rule already exists"
        return 0
    fi
    
    # Create temp file
    local temp_file
    temp_file=$(mktemp)
    
    # Write everything up to and including marker line
    head -n "$marker_line" "$file" > "$temp_file"
    
    # Add the new rule
    echo "$rule" >> "$temp_file"
    
    # Append the rest
    tail -n +$((marker_line + 1)) "$file" >> "$temp_file"
    
    # Replace original file
    cp "$temp_file" "$file"
    rm "$temp_file"
    
    info "Added rule to $file"
}

# Delete a rule (fuzzy match by pattern)
function delete_rule_by_pattern() {
    local file="$1"
    local marker="$2"
    local pattern="$3"  # A substring or multiple substrings to match
    
    if [[ ! -f "$file" ]]; then
        return 0
    fi
    
    local marker_line
    marker_line=$(find_marker_line "$file" "$marker")
    
    if [[ -z "$marker_line" ]]; then
        return 0
    fi
    
    # Check if pattern exists after the marker line
    local found=false
    local temp_file
    temp_file=$(mktemp)
    
    local line_num=0
    while IFS= read -r line || [[ -n "$line" ]]; do
        ((line_num++))
        
        # Check if line contains ALL pattern components and is after marker
        if [[ $line_num -gt $marker_line ]] && [[ -n "$pattern" ]]; then
            local should_delete=true
            
            # If pattern contains "--dport", check for port match
            if [[ "$pattern" =~ --dport\ ([0-9]+) ]]; then
                local port="${BASH_REMATCH[1]}"
                if [[ ! "$line" = *--dport\ $port* ]]; then
                    should_delete=false
                fi
            fi
            
            # If pattern contains "-s", check for source match  
            if [[ "$pattern" =~ -s\ (.+) ]]; then
                local src="${BASH_REMATCH[1]}"
                if [[ ! "$line" = *-s\ $src* ]]; then
                    should_delete=false
                fi
            fi
            
            # Delete the line if ALL pattern components match
            if [[ "$should_delete" == true ]]; then
                found=true
                info "Deleting line: $line"
                continue
            fi
        fi
        
        echo "$line" >> "$temp_file"
    done < "$file"
    
    if [[ "$found" == true ]]; then
        cp "$temp_file" "$file"
        info "Deleted matching rule from $file"
        rm "$temp_file"
        return 0
    fi
    
    rm "$temp_file"
    return 1
}

# Parse ufw-style arguments and extract relevant info
function parse_ufw_args() {
    local args=("$@")
    local proto=""
    local port=""
    local src=""
    local dst=""
    
    local i=0
    while [[ $i -lt ${#args[@]} ]]; do
        local arg="${args[$i]}"
        local next_arg="${args[$i+1]:-}"
        
        case "$arg" in
            proto)
                ((i++))
                proto="$next_arg"
                ;;
            protocol)
                ((i++))
                proto="$next_arg"
                ;;
            from)
                ((i++))
                src="$next_arg"
                ;;
            to)
                ((i++))
                dst="$next_arg"
                ;;
            port)
                ((i++))
                port="$next_arg"
                ;;
            in)
                ((i++))
                # Ignore interface for now
                ;;
            out)
                ((i++))
                # Ignore interface for now
                ;;
            *)
                # Handle inline formats
                if [[ "$arg" =~ ^[0-9]+(/(tcp|udp))$ ]]; then
                    # Format: "80/tcp" or "53/udp"
                    port="${arg%%/*}"
                    proto="${arg#*/}"
                elif [[ "$arg" =~ ^[0-9]+$ ]] && [[ -z "$port" ]]; then
                    # Just a number: assume it's a port
                    port="$arg"
                elif [[ "$arg" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}/[0-9]+$ ]]; then
                    # IPv4 with CIDR
                    [[ -z "$src" ]] && src="$arg"
                elif [[ "$arg" =~ ^[0-9a-fA-F:]+/[0-9]+$ ]]; then
                    # IPv6 with CIDR
                    [[ -z "$src" ]] && src="$arg"
                fi
                ;;
        esac
        
        ((i++))
    done
    
    # Set defaults
    proto="${proto:-tcp}"
    
    echo "$proto|$port|$src|$dst"
}

# Build iptables rule
function build_iptables_rule() {
    local action="$1"  # allow, deny, reject
    shift
    
    local parsed
    parsed=$(parse_ufw_args "$@")
    
    local proto="${parsed%%|*}"
    local rest="${parsed#*|}"
    local port="${rest%%|*}"
    local rest2="${rest#*|}"
    local src="${rest2%%|*}"
    local dst="${rest2#*|}"
    
    # Start building the rule
    local rule="-A DOCKER-USER"
    
    # Add protocol
    if [[ -n "$proto" ]]; then
        rule="$rule -p $proto"
    fi
    
    # Add destination port if port is specified
    if [[ -n "$port" ]]; then
        rule="$rule -m $proto --dport $port"
    fi
    
    # Add source IP
    if [[ -n "$src" ]]; then
        rule="$rule -s $src"
    fi
    
    # Add destination IP
    if [[ -n "$dst" ]]; then
        rule="$rule -d $dst"
    fi
    
    # Add the target action
    case "$action" in
        allow)
            rule="$rule -j RETURN"
            ;;
        deny)
            rule="$rule -j DROP"
            ;;
        reject)
            rule="$rule -j REJECT --reject-with icmp-port-unreachable"
            ;;
        *)
            rule="$rule -j RETURN"
            ;;
    esac
    
    echo "$rule"
}

# Build pattern for deletion - use multiple patterns for better matching
function build_delete_pattern() {
    local args=("$@")
    
    local parsed
    parsed=$(parse_ufw_args "${args[@]}")
    
    local proto="${parsed%%|*}"
    local rest="${parsed#*|}"
    local port="${rest%%|*}"
    local rest2="${rest#*|}"
    local src="${rest2%%|*}"
    
    # Build pattern string for matching
    # We'll match the key components that uniquely identify the rule
    local pattern=""
    local parts=()
    
    # Add port pattern if port is specified
    if [[ -n "$port" ]]; then
        parts+=("--dport $port")
    fi
    
    # Add source pattern if specified
    if [[ -n "$src" ]]; then
        parts+=("-s $src")
    fi
    
    # Combine parts
    if [[ ${#parts[@]} -gt 0 ]]; then
        pattern=$(IFS=" " ; echo "${parts[*]}")
    fi
    
    # Debug output
    info "Delete pattern: $pattern"
    
    echo "$pattern"
}

# Download file from GitHub with error handling
function download_from_github() {
    local url="$1"
    local output="$2"
    local description="$3"
    
    info "Downloading $description from GitHub..."
    
    # Check if curl is available
    if ! command -v curl >/dev/null 2>&1; then
        die "curl is required but not installed. Please install curl first."
    fi
    
    # Try to download with timeout and retry
    if ! curl -fsSL --connect-timeout 10 --max-time 30 --retry 2 "$url" -o "$output" 2>/dev/null; then
        local status_code
        status_code=$(curl -sSLo /dev/null -w "%{http_code}" --connect-timeout 10 "$url" 2>/dev/null || echo "000")
        
        if [[ -f "$output" ]]; then
            rm -f "$output"
        fi
        
        die "Failed to download $description from GitHub." \
            "Status code: $status_code" \
            "URL: $url" \
            "Please check your network connection and try again later." \
            "Your UFW configuration was not modified."
    fi
    
    # Verify downloaded file is not empty
    if [[ ! -s "$output" ]]; then
        rm -f "$output"
        die "Downloaded $description is empty. Your UFW configuration was not modified."
    fi
    
    info "✓ Downloaded $description"
}

# Handle init command
function handle_init() {
    info "Initializing ufwd..."
    
    # Resolve full paths for init files
    # Try in this order:
    # 1. Next to the script (./after.rules)
    # 2. In script's directory
    # 3. In /usr/local/share/ufwd
    # 4. In /etc/ufwd
    # 5. Download from GitHub
    local init_after init_after6
    local temp_dir
    
    for candidate in \
        "${0%/*}/after.rules" \
        "$(dirname "$(readlink -f "$0")")/after.rules" \
        "/usr/local/share/ufwd/after.rules" \
        "/etc/ufwd/after.rules" \
        "./after.rules"; do
        if [[ -f "$candidate" ]]; then
            init_after="$candidate"
            break
        fi
    done
    
    for candidate in \
        "${0%/*}/after6.rules" \
        "$(dirname "$(readlink -f "$0")")/after6.rules" \
        "/usr/local/share/ufwd/after6.rules" \
        "/etc/ufwd/after6.rules" \
        "./after6.rules"; do
        if [[ -f "$candidate" ]]; then
            init_after6="$candidate"
            break
        fi
    done
    
    # If not found locally, download from GitHub
    if [[ ! -f "$init_after" ]] || [[ ! -f "$init_after6" ]]; then
        temp_dir=$(mktemp -d)
        
        if [[ ! -f "$init_after" ]]; then
            download_from_github "${GITHUB_BASE}/after.rules" "$temp_dir/after.rules" "after.rules"
            init_after="$temp_dir/after.rules"
        fi
        
        if [[ ! -f "$init_after6" ]]; then
            download_from_github "${GITHUB_BASE}/after6.rules" "$temp_dir/after6.rules" "after6.rules"
            init_after6="$temp_dir/after6.rules"
        fi
        
        # Cleanup temp directory on exit
        trap "rm -rf \"$temp_dir\"" EXIT
    fi
    
    info "Using init files from:"
    info "  IPv4: $init_after"
    info "  IPv6: $init_after6"
    
    # Backup original files if they don't exist yet
    if [[ ! -f "$AFTER_RULES_ORIGINAL" ]]; then
        info "Backing up original files..."
        if [[ -f "$AFTER_RULES" ]]; then
            cp "$AFTER_RULES" "$AFTER_RULES_ORIGINAL"
            info "✓ Backed up $AFTER_RULES to $AFTER_RULES_ORIGINAL"
        fi
    else
        info "Original backup already exists: $AFTER_RULES_ORIGINAL (skipping backup)"
    fi
    
    if [[ ! -f "$AFTER6_RULES_ORIGINAL" ]]; then
        if [[ -f "$AFTER6_RULES" ]]; then
            cp "$AFTER6_RULES" "$AFTER6_RULES_ORIGINAL"
            info "✓ Backed up $AFTER6_RULES to $AFTER6_RULES_ORIGINAL"
        fi
    else
        info "Original backup already exists: $AFTER6_RULES_ORIGINAL (skipping backup)"
    fi
    
    info "Installing initial rule files..."
    cp "$init_after" "$AFTER_RULES"
    info "✓ Installed $AFTER_RULES"
    
    cp "$init_after6" "$AFTER6_RULES"
    info "✓ Installed $AFTER6_RULES"
    
    info ""
    info "Setup complete! Please restart UFW to apply changes:"
    info "  sudo systemctl restart ufw"
    info ""
    info "To restore original files, use: sudo ufwd uninit"
}

# Handle uninit command
function handle_uninit() {
    info "Uninitializing ufwd..."
    
    # Check if original backups exist
    local restored=false
    
    if [[ -f "$AFTER_RULES_ORIGINAL" ]]; then
        info "Restoring $AFTER_RULES from original backup..."
        cp "$AFTER_RULES_ORIGINAL" "$AFTER_RULES"
        info "✓ Restored $AFTER_RULES"
        restored=true
    else
        info "⚠ No original backup found for $AFTER_RULES"
    fi
    
    if [[ -f "$AFTER6_RULES_ORIGINAL" ]]; then
        info "Restoring $AFTER6_RULES from original backup..."
        cp "$AFTER6_RULES_ORIGINAL" "$AFTER6_RULES"
        info "✓ Restored $AFTER6_RULES"
        restored=true
    else
        info "⚠ No original backup found for $AFTER6_RULES"
    fi
    
    if [[ "$restored" == true ]]; then
        info ""
        info "✓ Original files restored!"
        info "  Please restart UFW to apply changes:"
        info "  sudo systemctl restart ufw"
    else
        info ""
        die "No original backup files found. Cannot restore."
    fi
}

# Handle allow/deny/reject commands
function handle_rule() {
    local action="$1"
    shift
    
    check_ufw strict
    
    # Build the iptables rule
    local rule
    rule=$(build_iptables_rule "$action" "$@")
    
    info "Adding rule: $rule"
    
    # Determine if this is IPv6 based on source or destination address in the rule itself
    local is_ipv6=false
    # Check if the rule contains IPv6 address (contains ::)
    if [[ "$rule" =~ :: ]]; then
        is_ipv6=true
    fi
    
    # Add to appropriate file(s)
    # IPv6 rules go to after6.rules only
    # IPv4 rules go to after.rules only
    if [[ "$is_ipv6" == true ]]; then
        # IPv6 address: only add to IPv6 file
        add_rule_after_marker "$AFTER6_RULES" "$SECTION_MARKER_IPV6" "$rule"
    else
        # IPv4 address or no address: only add to IPv4 file
        add_rule_after_marker "$AFTER_RULES" "$SECTION_MARKER_IPV4" "$rule"
    fi
    
    info ""
    info "✓ Rule added successfully!"
    info "  Restart UFW to apply: sudo systemctl restart ufw"
}

# Handle delete command
function handle_delete() {
    local first_arg="${1:-}"
    
    # If first arg is not allow/deny/reject, pass to ufw
    if [[ "$first_arg" != "allow" && "$first_arg" != "deny" && "$first_arg" != "reject" ]]; then
        # This is likely a numbered delete: pass to ufw
        ufw "$@"
        return
    fi
    
    local action="$first_arg"
    shift
    
    check_ufw strict
    
    # Build pattern for deletion
    local pattern
    pattern=$(build_delete_pattern "$@")
    
    if [[ -z "$pattern" ]]; then
        die "Unable to determine pattern for deletion. Please specify port or source."
    fi
    
    info "Deleting rules matching: $pattern"
    
    local deleted_v4=false
    local deleted_v6=false
    
    if delete_rule_by_pattern "$AFTER_RULES" "$SECTION_MARKER_IPV4" "$pattern"; then
        deleted_v4=true
    fi
    
    if delete_rule_by_pattern "$AFTER6_RULES" "$SECTION_MARKER_IPV6" "$pattern"; then
        deleted_v6=true
    fi
    
    if [[ "$deleted_v4" == true ]] || [[ "$deleted_v6" == true ]]; then
        info "✓ Rule deleted!"
        info "  Restart UFW to apply: sudo systemctl restart ufw"
    else
        info "No matching rule found"
    fi
}

# Main command dispatcher
function main() {
    local cmd="${1:-help}"
    
    case "$cmd" in
        init)
            # ufwd-specific: initialize rule files
            handle_init "$@"
            ;;
        uninit)
            # ufwd-specific: restore original rule files
            handle_uninit "$@"
            ;;
        allow|deny|reject)
            # Handle rule additions
            handle_rule "$cmd" "$@"
            ;;
        limit)
            # limit command behaves like allow but with rate limiting
            # For ufwd, we'll pass it through to ufw since it's not commonly
            # used for Docker port management. If needed, it can be handled similarly to allow
            ufw "$@"
            ;;
    delete)
            # Handle rule deletions
            handle_delete "$@"
            ;;
        insert|prepend)
            # insert/prepend are for manipulating existing rules by position
            # These don't fit well with ufwd's model of adding to a specific section
            # Pass through to ufw
            ufw "$@"
            ;;
        route|"route delete"|"route insert")
            # Route commands are for NAT rules, pass to ufw
            ufw "$@"
            ;;
        enable|disable)
            # Enable/disable firewall
            ufw "$@"
            ;;
        default|logging)
            # Set defaults and logging level
            ufw "$@"
            ;;
        reload|reset)
            # Reload or reset firewall
            ufw "$@"
            ;;
        status|"status numbered"|"status verbose")
            # Show firewall status
            ufw "$@"
            ;;
        show)
            # Show firewall report
            ufw "$@"
            ;;
        version)
            # Show version information
            echo "ufwd - UFW Docker port management wrapper"
            echo "Wrapped ufw version:"
            ufw "$@"
            ;;
        app)
            # Application profile commands
            ufw "$@"
            ;;
        help|--help|-h)
            # Show help
            echo "UFWD - UFW Docker Port Management"
            echo ""
            echo "Usage: ufwd COMMAND"
            echo ""
            echo "UFWD-specific commands:"
            echo "  init              Initialize ufwd rule files"
            echo "  uninit            Restore original UFW rule files"
            echo ""
            echo "Rule management (rules added to 'Container port access' section):"
            echo "  allow ARGS        add allow rule"
            echo "  deny ARGS         add deny rule"
            echo "  reject ARGS       add reject rule"
            echo "  delete allow ARGS delete allow rule"
            echo "  delete deny ARGS  delete deny rule"
            echo ""
            echo "All other UFW commands are passed through to ufw:"
            echo "  status            show firewall status"
            echo "  enable/disable    enable/disable firewall"
            echo "  reload/reset      reload/reset firewall"
            echo "  app               application profile commands"
            echo ""
            echo "Examples:"
            echo "  sudo ufwd init"
            echo "  sudo ufwd allow 80/tcp"
            echo "  sudo ufwd allow 443/tcp from 173.245.48.0/20"
            echo "  sudo ufwd delete allow 80/tcp"
            echo "  sudo ufwd status"
            echo ""
            echo "For full UFW documentation, see: man ufw"
            ;;
        *)
            # Pass everything else to ufw
            ufw "$@"
        ;;
esac
}

# Run main
main "$@"